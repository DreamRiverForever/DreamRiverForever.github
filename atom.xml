<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Java</title>
  
  <subtitle>JavaWeb</subtitle>
  <link href="/DreamRiverForever.github.io/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2018-12-30T14:54:46.480Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>Deng Yu Wen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FirstDay</title>
    <link href="https://yoursite.com/2018/12/30/FirstDay/"/>
    <id>https://yoursite.com/2018/12/30/FirstDay/</id>
    <published>2018-12-30T13:37:09.000Z</published>
    <updated>2018-12-30T14:54:46.480Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;h2 id=&quot;一-实现多线程的两种方式&quot;&gt;&lt;a href=&quot;#一-实现多线程的两种方式&quot; class=&quot;headerlink&quot; title=&quot;一.实现多线程的两种方式&quot;&gt;&lt;/a&gt;一.实现多线程的两种方式&lt;/h2&gt;&lt;p&gt;###1：继承Thread类重写run方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class  Demo1 {
public static void main(String[] args) {
    MyThread myThread = new MyThread();
    myThread.start();//开启线程
    for (int i=0;i&amp;lt;100;i++){
        System.out.println(&amp;quot;bb&amp;quot;);
    }
  }
}

class MyThread extends Thread{
    @Override
    public void run() {
      for (int i=0;i&amp;lt;100;i++)
       System.out.println(&amp;quot;aaaaa&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###2:实现Runnable接口在Thread构造函数中传入Runnable子类对象&lt;br&gt;    public class Demo2 {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            MyRunnable mr = new MyRunnable();&lt;br&gt;            Thread t =new Thread(mr);//传入Runnable子类对象&lt;br&gt;            t.start();//开启线程&lt;br&gt;            for (int i=0;i&amp;lt;100;i++)&lt;br&gt;                System.out.println(“bb”);&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyRunnable implements Runnable{//实现Runnable接口
    @Override
    public void run() {//重写run方法
        for (int i=0;i&amp;lt;100;i++)
            System.out.println(Thread.currentThread().getName()+i);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###3:使用线程池创建多线程&lt;br&gt;    public class Demo21_Executors {//线程池&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            ExecutorService pool = Executors.newFixedThreadPool(2);&lt;br&gt;            pool.submit(new Thread(new MyRunnable()));&lt;br&gt;            pool.submit(new Thread(new MyRunnable()));&lt;br&gt;            pool.shutdown();//关闭线程池&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;线程池中线程不会死亡，可以减少线程的创建但是浪费资源&lt;/p&gt;
&lt;p&gt;##二.使用匿名内部类实现线程&lt;br&gt;    public class Demo3 {&lt;br&gt;        public static void main(String[] args) {//匿名内部类&lt;br&gt;            new Thread(){//继承Threadlei&lt;br&gt;                @Override&lt;br&gt;                public void run() {//重写run方法&lt;br&gt;                    for (int i=0;i&amp;lt;100;i++)&lt;br&gt;                        System.out.println(“aaaaa”);&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(new Runnable() {//将runnable子类对象放入Thread构造函数&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;100;i++)&lt;br&gt;                        System.out.println(“bbb”);&lt;br&gt;                }&lt;br&gt;            }).start();&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;##三.线程的一些使用方法&lt;/p&gt;
&lt;p&gt;###1. setname用于设置线程名称&lt;br&gt;    public class Demo4 {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            new Thread(){//可以传入字符串命名&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    this.setName(“dengyuwen”);//也可以setname方法设置名字&lt;br&gt;                    System.out.println(this.getName()+”   aaa”);//获取线程的name&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    this.setName(“hejianan”);&lt;br&gt;                    System.out.println(this.getName()+”   bbb”);&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;###2.getname用于获取线程名称&lt;br&gt;    public class Demo5 {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    System.out.println(getName()+”    aaa”);//获取线程名称&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(new Runnable() {&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    System.out.println(Thread.currentThread().getName()+”    bbb”);//Thread.currentThread()获取当前执行线程，因为Runnable没有getname方法&lt;br&gt;                }&lt;br&gt;            }).start();&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;###3.sleep用于休眠线程&lt;br&gt;    public class Demo6Sleep {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            for (int i=20;i&amp;gt;=0;i–){&lt;br&gt;                try {&lt;br&gt;                    Thread.sleep(1000);&lt;br&gt;                } catch (InterruptedException e) {&lt;br&gt;                    e.printStackTrace();&lt;br&gt;                }&lt;br&gt;                System.out.println(“倒计时第”+i+”秒”);&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;###4.Daemon守护线程&lt;br&gt;    public class Demo7Daemon {//守护线程&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            Thread t1 = new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;2;i++)&lt;br&gt;                        System.out.println(getName()+”   aaaaa”);&lt;br&gt;                }&lt;br&gt;            };&lt;br&gt;            Thread t2 = new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;12;i++)&lt;br&gt;                        System.out.println(getName()+”   bbbbb”);&lt;br&gt;                }&lt;br&gt;            };&lt;br&gt;            t2.setDaemon(true);//设置守护线程，当非守护线程死亡守护线程也死亡&lt;br&gt;            t1.start();&lt;br&gt;            t2.start();&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;设置守护线程，当非守护线程死亡守护线程也死亡&lt;/p&gt;
&lt;p&gt;###5.join加入线程&lt;br&gt;    public class Demo8Join {//加入线程&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            final Thread t1 = new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;12;i++)&lt;br&gt;                        System.out.println(getName()+”   aaaaa”);&lt;br&gt;                }&lt;br&gt;            };&lt;br&gt;            final Thread t2 = new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;12;i++){&lt;br&gt;                        if (i==2) {&lt;br&gt;                            try {&lt;br&gt;                                t1.join();//插队，t2执行两次，t1加入执行到结束t2才能执行。在join中可以传入插队时间&lt;br&gt;                            } catch (InterruptedException e) {&lt;br&gt;                                e.printStackTrace();&lt;br&gt;                            }&lt;br&gt;                        }&lt;br&gt;                        System.out.println(getName()+”   bbbbb”);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                }

            }
        };
        t1.start();
        t2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###6.SetPriority线程优先级&lt;br&gt;    public class Demo10SetPriority {//设置进程优先级&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public static void main(String[] args) {
        Thread t1 = new Thread(){
            @Override
            public void run() {
                for (int i=0;i&amp;lt;1000;i++){
                    System.out.println(getName()+&amp;quot;   aaa&amp;quot;);
                }
            }
        };
        Thread t2 = new Thread(){
            @Override
            public void run() {
                for (int i=0;i&amp;lt;1000;i++){
                    System.out.println(getName()+&amp;quot;   bbb&amp;quot;);
                }
            }
        };
        t1.setPriority(10);//优先级10最大，1最小
        t2.setPriority(1);
        t1.start();
        t2.start();

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置优先级不意味着按照优先级执行，而是给cup提供资源分配提示，最后还是由cup决定执行顺序&lt;/p&gt;
&lt;p&gt;###7.synchronized同步代码块(重要)&lt;br&gt;    public class Demo11syn {&lt;br&gt;        //同步代码块&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            final Printer p =  new Printer();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;1000;i++){&lt;br&gt;                        p.print1();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;1000;i++){&lt;br&gt;                        p.print2();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    }
}
class Printer{
    Demo d = new Demo();
    public void print1(){
        synchronized (d){//同步锁传入同一个对象必须执行完括号里面的代码
            System.out.print(&amp;quot;黑&amp;quot;);
            System.out.print(&amp;quot;马&amp;quot;);
            System.out.print(&amp;quot;程&amp;quot;);
            System.out.print(&amp;quot;序&amp;quot;);
            System.out.print(&amp;quot;员&amp;quot;);
            System.out.println();
        }



    }
    public void print2(){
        synchronized (d){//必须同一对象
            System.out.print(&amp;quot;传&amp;quot;);
            System.out.print(&amp;quot;智&amp;quot;);
            System.out.print(&amp;quot;播&amp;quot;);
            System.out.print(&amp;quot;客&amp;quot;);
            System.out.println();
        }
    }
}
class Demo{

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;线程在cup分给的时间片使用完后，有可能代码执行一半而转去执行其他&lt;br&gt;线程，这样容易引起线程安全问题，同步代码块强制执行完整代码才释放&lt;br&gt;锁对象。例如在火车买票剩余2张，2&amp;gt;0于是进入买票，在买票过程中cup分配&lt;br&gt;的时间用完转去执行其他线程，有可能在此期间票卖完。但是在又获取时间片&lt;br&gt;后线程继续执行，但是票卖完，于是ticket–，变成-1等等一些负数，引起线程&lt;br&gt;不安全。使用synchronized关键字，在进入代码块后必须执行完才推出即释放锁对象&lt;br&gt;。除非有wait()方法提前释放了锁对象。&lt;/p&gt;
&lt;p&gt;###8.锁对象可以使任意的&lt;br&gt;    public class Demo12syn2 {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            final Printer2 p =  new Printer2();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;1000;i++){&lt;br&gt;                        p.print1();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    for (int i=0;i&amp;lt;1000;i++){&lt;br&gt;                        p.print2();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    }
}
class Printer2{
    Demo d = new Demo();
    //非静态同步方法的锁对象是this
    //静态同步方法锁对象时字节文件.class
    public synchronized void print1(){
            System.out.print(&amp;quot;黑&amp;quot;);
            System.out.print(&amp;quot;马&amp;quot;);
            System.out.print(&amp;quot;程&amp;quot;);
            System.out.print(&amp;quot;序&amp;quot;);
            System.out.print(&amp;quot;员&amp;quot;);
            System.out.println();
    }
    public void print2(){
        synchronized (this){
            System.out.print(&amp;quot;传&amp;quot;);
            System.out.print(&amp;quot;智&amp;quot;);
            System.out.print(&amp;quot;播&amp;quot;);
            System.out.print(&amp;quot;客&amp;quot;);
            System.out.println();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###9.火车买票问题&lt;br&gt;    public class Demo13 {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            MyTicket mt = new MyTicket();//创建一次对象ticket不在需要共用&lt;br&gt;            new Thread(mt).start();//锁对象可以用this&lt;br&gt;            new Thread(mt).start();//多次启动一个线程是非法的&lt;br&gt;            new Thread(mt).start();&lt;br&gt;            new Thread(mt).start();&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyTicket implements Runnable{
    private int ticket=100;
    @Override
    public void run() {
        while (true){
            synchronized (Ticket.class){//同步代码块。参数必须是同一把锁，引用对象必须是静态的
                if (ticket==0)
                    break;
                try {
                    Thread.sleep(10);//线程1234等于1时，每次减一变成负数跳过ticket==0判断买负数票，所以必须同步ticket--。
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+&amp;quot; 这是第 &amp;quot;+ticket--+&amp;quot; 号票&amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###10.哲学家就餐问题&lt;br&gt;    public class Demo14deadlock {&lt;br&gt;          private static String s1=”筷子左”;&lt;br&gt;          private static String s2=”筷子右”;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      public static void main(String[] args) {//死锁避免同步代码块嵌套
          new Thread(){
              @Override
              public void run() {

                      while (true){
                          synchronized (s1){
                          System.out.println(getName()+&amp;quot; 获取 &amp;quot;+s1+&amp;quot; 等待 &amp;quot;+s2);//获取不到s2
                          synchronized (s2){
                              System.out.println(getName()+&amp;quot; 拿到 &amp;quot;+s2+&amp;quot;开吃&amp;quot;);
                          }

                          }
                      }
              }
          }.start();

          new Thread(){
              @Override
              public void run() {

                  while (true){
                      synchronized (s2){
                          System.out.println(getName()+&amp;quot; 获取 &amp;quot;+s2+&amp;quot; 等待 &amp;quot;+s1);
                          synchronized (s1){//获取不到s1
                              System.out.println(getName()+&amp;quot; 拿到 &amp;quot;+s1+&amp;quot;开吃&amp;quot;);
                          }

                      }
                  }
              }
          }.start();

      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###11.Singleton单例设计模式(重要)&lt;br&gt;    public class Demo15Singleton {//单例设计模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public static void main(String[] args) {
        SingLeton s1 = SingLeton.getS();
        SingLeton s2 = SingLeton.getS();
        System.out.println(s1==s2);

    }
}
//饿汉式    比较好
class SingLeton{
    private SingLeton(){//私有构造方法，其他类不能访问该方法
    }
    //也可以public，但是必须加final关键字，不可改变，只能创建一个对象
    private static SingLeton s = new SingLeton();//设置为静态可以使用类名点s

    public static SingLeton getS() {//只能拿不能改
        return s;
    }
}
//懒汉式   线程不安全
class SingLeton2{
    private SingLeton2(){//私有构造方法，其他类不能访问该方法
    }

    private static SingLeton2 s;

    public static SingLeton2 getS() {//只能拿不能改
        if (s == null){
            //线程1进入等待，线程2进入，创建了两个对象不是单例设计模式
            s = new SingLeton2();
        }
        return s;
    }
}
/*
 *饿汉式空间换时间，先创建对象浪费内存，调用快
 * 懒汉式是时间换空间，先声明不创建，在判断要不要创建，浪费时间
 * 在多线程访问时饿汉式不会创建多个对象，懒汉式有可能创建多个对象
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###12.Timer定时器&lt;br&gt;    public class Demo17Timer {&lt;br&gt;        public static void main(String[] args) {//定时器,指定时间安排指定任务&lt;br&gt;            Timer t = new Timer();&lt;br&gt;            t.schedule(new MyTimerTask(),new Date());//参数安排任务，执行的时间，过多长时间在重复执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    }
}
class MyTimerTask extends TimerTask{
    @Override
    public void run() {
        System.out.println(&amp;quot;起来了背书了&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在指定时间执行特定的任务&lt;/p&gt;
&lt;p&gt;###13.wait &amp;amp; notify等待唤醒机制&lt;br&gt;    public class Demo18_notify {//等待唤醒机制&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;           final Printer3 p= new Printer3();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    while(true) {&lt;br&gt;                        p.print1();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                }
            }
        }.start();
        new Thread(){
            @Override
            public void run() {
                while(true) {
                    p.print2();

                }
            }
        }.start();
    }
}
class Printer3{
    private int flag=1;
    public void print1(){
        synchronized (this){
            if (flag!=1){
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;黑&amp;quot;);
            System.out.print(&amp;quot;马&amp;quot;);
            System.out.print(&amp;quot;程&amp;quot;);
            System.out.print(&amp;quot;序&amp;quot;);
            System.out.print(&amp;quot;员&amp;quot;);
            System.out.println();
            flag = 2;
            this.notify();
        }
    }
    public void print2(){
        synchronized (this){
            if (flag!=2){
                try {
                    this.wait();//进入等待线程队列
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;传&amp;quot;);
            System.out.print(&amp;quot;智&amp;quot;);
            System.out.print(&amp;quot;播&amp;quot;);
            System.out.print(&amp;quot;客&amp;quot;);
            System.out.println();
            flag = 1;
            this.notify();//随机唤醒一个线程
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;随机唤醒一个线程，由于线程在哪里等待就在那里唤醒有可能越过if判断。所以提前释放锁对象容易出现线程安全。&lt;/p&gt;
&lt;p&gt;###14.notifyall唤醒全部线程&lt;br&gt;    public class Demo19_notifyall {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            Printer4 p = new Printer4();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    while (true){&lt;br&gt;                        p.print1();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    while (true){&lt;br&gt;                        p.print2();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    while (true){&lt;br&gt;                        p.print3();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    }
}
/*
 *用什么对象锁，就要用那个对象调用wait方法
 * wait、notify方法必须在object中，object是所有类的基类，锁对象可以使任意的。
 *
 */
class Printer4{
    private int flag=1;
    public void print1(){
        synchronized (this){
            while (flag!=1){
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;黑&amp;quot;);
            System.out.print(&amp;quot;马&amp;quot;);
            System.out.print(&amp;quot;程&amp;quot;);
            System.out.print(&amp;quot;序&amp;quot;);
            System.out.print(&amp;quot;员&amp;quot;);
            System.out.println();
            flag = 2;
            this.notifyAll();
        }
    }
    public void print2(){
        synchronized (this){
            while (flag!=2){
                try {
                    this.wait();//进入等待线程队列
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;传&amp;quot;);
            System.out.print(&amp;quot;智&amp;quot;);
            System.out.print(&amp;quot;播&amp;quot;);
            System.out.print(&amp;quot;客&amp;quot;);
            System.out.println();
            flag = 3;
            this.notifyAll();//随机唤醒所有线程
        }
    }
    public void print3(){
        synchronized (this){
            while (flag!=3){
                try {
                    this.wait();//进入等待线程队列
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;i&amp;quot;);
            System.out.print(&amp;quot;t&amp;quot;);
            System.out.print(&amp;quot;h&amp;quot;);
            System.out.print(&amp;quot;m&amp;quot;);
            System.out.println();
            flag = 1;
            this.notifyAll();//随机唤醒所有线程
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;notify容易造成死锁，例如flag = 1 执行完 flag = 2 随机唤醒线程3，&lt;br&gt;由于使用while判断所以不能越过，2！= 3 所以线程3再次等待，&lt;br&gt;至此没有执行的线程，所有线程都在等待，造成死锁。使用notifyll唤醒所有线程&lt;br&gt;可以保证有执行的线程，不至于死锁。&lt;/p&gt;
&lt;p&gt;###15.ReentrantLock同步锁(重要)&lt;br&gt;    public class Demo20_ReentrantLock {&lt;br&gt;        public static void main(String[] args) {&lt;br&gt;            final Printer5 p = new Printer5();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    while (true){&lt;br&gt;                        p.print1();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    while (true){&lt;br&gt;                        p.print2();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;br&gt;            new Thread(){&lt;br&gt;                @Override&lt;br&gt;                public void run() {&lt;br&gt;                    while (true){&lt;br&gt;                        p.print3();&lt;br&gt;                    }&lt;br&gt;                }&lt;br&gt;            }.start();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    }
}


class Printer5{
    private ReentrantLock r = new ReentrantLock();
    private Condition c  =  r.newCondition();
    private Condition c1 =  r.newCondition();
    private Condition c2 =  r.newCondition();
    private int flag=1;
    public void print1(){
        r.lock();
            if (flag!=1){
                try {
                    c.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;黑&amp;quot;);
            System.out.print(&amp;quot;马&amp;quot;);
            System.out.print(&amp;quot;程&amp;quot;);
            System.out.print(&amp;quot;序&amp;quot;);
            System.out.print(&amp;quot;员&amp;quot;);
            System.out.println();
            flag = 2;
            c1.signal();
        r.unlock();
    }
    public void print2(){
        r.lock();
            if (flag!=2){
                try {
                    c1.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;传&amp;quot;);
            System.out.print(&amp;quot;智&amp;quot;);
            System.out.print(&amp;quot;播&amp;quot;);
            System.out.print(&amp;quot;客&amp;quot;);
            System.out.println();
            flag = 3;
            c2.signal();
        r.unlock();
    }
    public void print3(){
        r.lock();
            if (flag!=3){
                try {
                    c2.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(&amp;quot;i&amp;quot;);
            System.out.print(&amp;quot;t&amp;quot;);
            System.out.print(&amp;quot;h&amp;quot;);
            System.out.print(&amp;quot;m&amp;quot;);
            System.out.println();
            flag = 1;
            c.signal();
        r.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="多线程" scheme="https://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>demo</title>
    <link href="https://yoursite.com/2018/12/30/demo/"/>
    <id>https://yoursite.com/2018/12/30/demo/</id>
    <published>2018-12-30T11:35:17.000Z</published>
    <updated>2018-12-30T11:35:17.336Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
