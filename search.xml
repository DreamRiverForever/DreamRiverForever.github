<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FirstDay]]></title>
    <url>%2FDreamRiverForever.github.io%2F2018%2F12%2F30%2FFirstDay%2F</url>
    <content type="text"><![CDATA[多线程 一.实现多线程的两种方式1：继承Thread类重写run方法public class Demo1 { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start();//开启线程 for (int i=0;i&lt;100;i++){ System.out.println(&quot;bb&quot;); } } } class MyThread extends Thread{ @Override public void run() { for (int i=0;i&lt;100;i++) System.out.println(&quot;aaaaa&quot;); } } 2:实现Runnable接口在Thread构造函数中传入Runnable子类对象public class Demo2 { public static void main(String[] args) { MyRunnable mr = new MyRunnable(); Thread t =new Thread(mr);//传入Runnable子类对象 t.start();//开启线程 for (int i=0;i&lt;100;i++) System.out.println(&quot;bb&quot;); } } class MyRunnable implements Runnable{//实现Runnable接口 @Override public void run() {//重写run方法 for (int i=0;i&lt;100;i++) System.out.println(Thread.currentThread().getName()+i); } } 3:使用线程池创建多线程public class Demo21_Executors {//线程池 public static void main(String[] args) { ExecutorService pool = Executors.newFixedThreadPool(2); pool.submit(new Thread(new MyRunnable())); pool.submit(new Thread(new MyRunnable())); pool.shutdown();//关闭线程池 } } 线程池中线程不会死亡，可以减少线程的创建但是浪费资源 二.使用匿名内部类实现线程public class Demo3 { public static void main(String[] args) {//匿名内部类 new Thread(){//继承Threadlei @Override public void run() {//重写run方法 for (int i=0;i&lt;100;i++) System.out.println(&quot;aaaaa&quot;); } }.start(); new Thread(new Runnable() {//将runnable子类对象放入Thread构造函数 @Override public void run() { for (int i=0;i&lt;100;i++) System.out.println(&quot;bbb&quot;); } }).start(); } } 三.线程的一些使用方法1.setname用于设置线程名称public class Demo4 { public static void main(String[] args) { new Thread(){//可以传入字符串命名 @Override public void run() { this.setName(&quot;dengyuwen&quot;);//也可以setname方法设置名字 System.out.println(this.getName()+&quot; aaa&quot;);//获取线程的name } }.start(); new Thread(){ @Override public void run() { this.setName(&quot;hejianan&quot;); System.out.println(this.getName()+&quot; bbb&quot;); } }.start(); } } 2.getname用于获取线程名称public class Demo5 { public static void main(String[] args) { new Thread(){ @Override public void run() { System.out.println(getName()+&quot; aaa&quot;);//获取线程名称 } }.start(); new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot; bbb&quot;);//Thread.currentThread()获取当前执行线程，因为Runnable没有getname方法 } }).start(); } } 3.sleep用于休眠线程public class Demo6Sleep { public static void main(String[] args) { for (int i=20;i&gt;=0;i--){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;倒计时第&quot;+i+&quot;秒&quot;); } } } 4.Daemon守护线程public class Demo7Daemon {//守护线程 public static void main(String[] args) { Thread t1 = new Thread(){ @Override public void run() { for (int i=0;i&lt;2;i++) System.out.println(getName()+&quot; aaaaa&quot;); } }; Thread t2 = new Thread(){ @Override public void run() { for (int i=0;i&lt;12;i++) System.out.println(getName()+&quot; bbbbb&quot;); } }; t2.setDaemon(true);//设置守护线程，当非守护线程死亡守护线程也死亡 t1.start(); t2.start(); } } 设置守护线程，当非守护线程死亡守护线程也死亡 5.join加入线程public class Demo8Join {//加入线程 public static void main(String[] args) { final Thread t1 = new Thread(){ @Override public void run() { for (int i=0;i&lt;12;i++) System.out.println(getName()+&quot; aaaaa&quot;); } }; final Thread t2 = new Thread(){ @Override public void run() { for (int i=0;i&lt;12;i++){ if (i==2) { try { t1.join();//插队，t2执行两次，t1加入执行到结束t2才能执行。在join中可以传入插队时间 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(getName()+&quot; bbbbb&quot;); } } }; t1.start(); t2.start(); } } 6.SetPriority线程优先级public class Demo10SetPriority {//设置进程优先级 public static void main(String[] args) { Thread t1 = new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ System.out.println(getName()+&quot; aaa&quot;); } } }; Thread t2 = new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ System.out.println(getName()+&quot; bbb&quot;); } } }; t1.setPriority(10);//优先级10最大，1最小 t2.setPriority(1); t1.start(); t2.start(); } } 设置优先级不意味着按照优先级执行，而是给cup提供资源分配提示，最后还是由cup决定执行顺序 7.synchronized同步代码块(重要)public class Demo11syn { //同步代码块 public static void main(String[] args) { final Printer p = new Printer(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print2(); } } }.start(); } } class Printer{ Demo d = new Demo(); public void print1(){ synchronized (d){//同步锁传入同一个对象必须执行完括号里面的代码 System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); } } public void print2(){ synchronized (d){//必须同一对象 System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); } } } class Demo{ } 线程在cup分给的时间片使用完后，有可能代码执行一半而转去执行其他线程，这样容易引起线程安全问题，同步代码块强制执行完整代码才释放锁对象。例如在火车买票剩余2张，2&gt;0于是进入买票，在买票过程中cup分配的时间用完转去执行其他线程，有可能在此期间票卖完。但是在又获取时间片后线程继续执行，但是票卖完，于是ticket–，变成-1等等一些负数，引起线程不安全。使用synchronized关键字，在进入代码块后必须执行完才推出即释放锁对象。除非有wait()方法提前释放了锁对象。 8.锁对象可以使任意的public class Demo12syn2 { public static void main(String[] args) { final Printer2 p = new Printer2(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print2(); } } }.start(); } } class Printer2{ Demo d = new Demo(); //非静态同步方法的锁对象是this //静态同步方法锁对象时字节文件.class public synchronized void print1(){ System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); } public void print2(){ synchronized (this){ System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); } } } 9.火车买票问题public class Demo13 { public static void main(String[] args) { MyTicket mt = new MyTicket();//创建一次对象ticket不在需要共用 new Thread(mt).start();//锁对象可以用this new Thread(mt).start();//多次启动一个线程是非法的 new Thread(mt).start(); new Thread(mt).start(); } } class MyTicket implements Runnable{ private int ticket=100; @Override public void run() { while (true){ synchronized (Ticket.class){//同步代码块。参数必须是同一把锁，引用对象必须是静态的 if (ticket==0) break; try { Thread.sleep(10);//线程1234等于1时，每次减一变成负数跳过ticket==0判断买负数票，所以必须同步ticket--。 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot; 这是第 &quot;+ticket--+&quot; 号票&quot;); } } } } 10.哲学家就餐问题public class Demo14deadlock { private static String s1=&quot;筷子左&quot;; private static String s2=&quot;筷子右&quot;; public static void main(String[] args) {//死锁避免同步代码块嵌套 new Thread(){ @Override public void run() { while (true){ synchronized (s1){ System.out.println(getName()+&quot; 获取 &quot;+s1+&quot; 等待 &quot;+s2);//获取不到s2 synchronized (s2){ System.out.println(getName()+&quot; 拿到 &quot;+s2+&quot;开吃&quot;); } } } } }.start(); new Thread(){ @Override public void run() { while (true){ synchronized (s2){ System.out.println(getName()+&quot; 获取 &quot;+s2+&quot; 等待 &quot;+s1); synchronized (s1){//获取不到s1 System.out.println(getName()+&quot; 拿到 &quot;+s1+&quot;开吃&quot;); } } } } }.start(); } } 11.Singleton单例设计模式(重要)public class Demo15Singleton {//单例设计模式 public static void main(String[] args) { SingLeton s1 = SingLeton.getS(); SingLeton s2 = SingLeton.getS(); System.out.println(s1==s2); } } //饿汉式 比较好 class SingLeton{ private SingLeton(){//私有构造方法，其他类不能访问该方法 } //也可以public，但是必须加final关键字，不可改变，只能创建一个对象 private static SingLeton s = new SingLeton();//设置为静态可以使用类名点s public static SingLeton getS() {//只能拿不能改 return s; } } //懒汉式 线程不安全 class SingLeton2{ private SingLeton2(){//私有构造方法，其他类不能访问该方法 } private static SingLeton2 s; public static SingLeton2 getS() {//只能拿不能改 if (s == null){ //线程1进入等待，线程2进入，创建了两个对象不是单例设计模式 s = new SingLeton2(); } return s; } } /* *饿汉式空间换时间，先创建对象浪费内存，调用快 * 懒汉式是时间换空间，先声明不创建，在判断要不要创建，浪费时间 * 在多线程访问时饿汉式不会创建多个对象，懒汉式有可能创建多个对象 */ 12.Timer定时器public class Demo17Timer { public static void main(String[] args) {//定时器,指定时间安排指定任务 Timer t = new Timer(); t.schedule(new MyTimerTask(),new Date());//参数安排任务，执行的时间，过多长时间在重复执行 } } class MyTimerTask extends TimerTask{ @Override public void run() { System.out.println(&quot;起来了背书了&quot;); } } 在指定时间执行特定的任务 13.wait &amp; notify等待唤醒机制public class Demo18_notify {//等待唤醒机制 public static void main(String[] args) { final Printer3 p= new Printer3(); new Thread(){ @Override public void run() { while(true) { p.print1(); } } }.start(); new Thread(){ @Override public void run() { while(true) { p.print2(); } } }.start(); } } class Printer3{ private int flag=1; public void print1(){ synchronized (this){ if (flag!=1){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); flag = 2; this.notify(); } } public void print2(){ synchronized (this){ if (flag!=2){ try { this.wait();//进入等待线程队列 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); flag = 1; this.notify();//随机唤醒一个线程 } } } 随机唤醒一个线程，由于线程在哪里等待就在那里唤醒有可能越过if判断。所以提前释放锁对象容易出现线程安全。 14.notifyall唤醒全部线程public class Demo19_notifyall { public static void main(String[] args) { Printer4 p = new Printer4(); new Thread(){ @Override public void run() { while (true){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { while (true){ p.print2(); } } }.start();new Thread(){ @Override public void run() { while (true){ p.print3(); } } }.start(); } } /* *用什么对象锁，就要用那个对象调用wait方法 * wait、notify方法必须在object中，object是所有类的基类，锁对象可以使任意的。 * */ class Printer4{ private int flag=1; public void print1(){ synchronized (this){ while (flag!=1){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); flag = 2; this.notifyAll(); } } public void print2(){ synchronized (this){ while (flag!=2){ try { this.wait();//进入等待线程队列 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); flag = 3; this.notifyAll();//随机唤醒所有线程 } } public void print3(){ synchronized (this){ while (flag!=3){ try { this.wait();//进入等待线程队列 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;i&quot;); System.out.print(&quot;t&quot;); System.out.print(&quot;h&quot;); System.out.print(&quot;m&quot;); System.out.println(); flag = 1; this.notifyAll();//随机唤醒所有线程 } } } notify容易造成死锁，例如flag = 1 执行完 flag = 2 随机唤醒线程3，由于使用while判断所以不能越过，2！= 3 所以线程3再次等待，至此没有执行的线程，所有线程都在等待，造成死锁。使用notifyll唤醒所有线程可以保证有执行的线程，不至于死锁。 15.ReentrantLock同步锁(重要)public class Demo20_ReentrantLock { public static void main(String[] args) { final Printer5 p = new Printer5(); new Thread(){ @Override public void run() { while (true){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { while (true){ p.print2(); } } }.start(); new Thread(){ @Override public void run() { while (true){ p.print3(); } } }.start(); } } class Printer5{ private ReentrantLock r = new ReentrantLock(); private Condition c = r.newCondition(); private Condition c1 = r.newCondition(); private Condition c2 = r.newCondition(); private int flag=1; public void print1(){ r.lock(); if (flag!=1){ try { c.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); flag = 2; c1.signal(); r.unlock(); } public void print2(){ r.lock(); if (flag!=2){ try { c1.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); flag = 3; c2.signal(); r.unlock(); } public void print3(){ r.lock(); if (flag!=3){ try { c2.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;i&quot;); System.out.print(&quot;t&quot;); System.out.print(&quot;h&quot;); System.out.print(&quot;m&quot;); System.out.println(); flag = 1; c.signal(); r.unlock(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
