<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FourthDay]]></title>
    <url>%2FDreamRiverForever.github.io%2F2019%2F01%2F07%2FFourthDay%2F</url>
    <content type="text"><![CDATA[XML解析 (一) 使用XML解析简单的对象属性文件XML可以存储一些配置文件和对象信息，此次介绍如何在xml文件中解析出有用的信息。 存在以下XML文件，请在以下文件中获取出Person对象信息 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;persons&gt; &lt;person&gt; &lt;name&gt;邓玉文&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;/person&gt; &lt;person&gt; &lt;name&gt;何佳楠&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;/person&gt; &lt;/persons&gt; 1.创建SAXParserFactory实例对象public class Xml { /*xml解析 *熟悉sax流程 */ public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException { SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser parser = factory.newSAXParser(); PHandler handler = new PHandler(); parser.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;WebServer/p.xml&quot;),handler); List&lt;Person&gt; personList = handler.getPersonList(); for (Person person: personList) { System.out.println(&quot;名字是&quot;+person.getName()+&quot; 年龄为&quot;+person.getAge()); } } } 2.创建继承于DefaultHandler的PHandler类继承DefaultHandler后重写父类中文件，元素处理的四大方法tartDocument()startElement()characters()endElement()endDocument() class PHandler extends DefaultHandler{ private List&lt;Person&gt; personList; private Person person; private String tag; public List&lt;Person&gt; getPersonList() { return personList; } @Override public void startDocument() throws SAXException { personList = new ArrayList&lt;Person&gt;(); } @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { System.out.println(qName+&quot;--&gt;解析开始&quot;+tag); if (qName!=null){ tag = qName; } if (qName.equals(&quot;person&quot;)){ person = new Person(); } } @Override public void characters(char[] ch, int start, int length) throws SAXException { String contents = new String(ch,start,length).trim();//有空的情况，因为xml文档中有空格 if (tag!=null){//解决空问题 if (tag.equals(&quot;name&quot;)){ person.setName(contents); }else if(tag.equals(&quot;age&quot;)){ if (contents.length()&gt;0){ person.setAge(Integer.valueOf(contents)); } } } } @Override public void endElement(String uri, String localName, String qName) throws SAXException { System.out.println(qName+&quot;--&gt;解析结束&quot;+tag); if (qName.equals(&quot;person&quot;)){ personList.add(person); } tag = null; } @Override public void endDocument() throws SAXException { System.out.println(&quot;解析文档结束&quot;); } } tag用于判断是否为空格，防止空格录入信息。 3.创建Javabean对象类Person用于存储数据class Person{ private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(){ } public String getName() { return name; } public int getAge() { return age; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } }]]></content>
      <categories>
        <category>XML</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThirdDay]]></title>
    <url>%2FDreamRiverForever.github.io%2F2019%2F01%2F01%2FThirdDay%2F</url>
    <content type="text"><![CDATA[网络编程 一.UDP1.UDP协议简单实现在有些应用程序中，保持最快的速度比保证每一位数据都正确到达更重要。例如，在实时音频或视频中，丢失数据包只会作为干扰出现。干扰是可以容忍的，但当TCP请求重传或等待数据包到达而它却迟迟不到时，音频流中就会出现尴尬的停顿，这让人无法接受的。在其他应用中，可以在应用层实现可靠性传输。例如：如果客户端向服务器发送一个短的UDP请求，倘若制定时间内没有响应返回，它会认为这个包已丢失。域名系统就是采用这样的工作方式。事实上，可以用UDP实现一个可靠的文件传输协议，而且很多人确实是这样做的：网络文件系统，简单FTP都使用了UDP协议。在这些协议中由应用程序来负责可靠性。java中的UDP实现分为两个类：DatagramPacket和 DatagramSocket。DatagramPacket类将数据字节填充到UDP包中，这称为数据报。 DatagramSocket来发送这个包。要接受数据，可以从DatagramSocket中接受一个 DatagramPack对象，然后从该包中读取数据的内容。这种职责的划分与TCP使用的Socket和ServerSocket有所不同。首先，UDP没有两台主机间唯一连接的概念，它不需要知道对方是哪个远程主机。它可以从一个端口往多个主机发送信息，但是TCP是无法做到的。其次，TCP socket把网络链接看作是流：通过从Socket得到的输入和输出流来收发数据。UDP不支持这一点，你处理总是单个数据包。填充在一个数据报中的所有数据会以包的形式进行发送，这些数据要么作为一个组要么全部接收，要么全部丢弃。一个包不一定与下一个包相关。给定两个包，没有办法知道哪个先发哪个后发。对于流来说，必须提供数据的有序队列，与之不同，数据报会尽可能快的蜂拥到接收方。 public class UDP {//发送端 public static void main(String[] args) throws Exception{ String str ; Scanner in = new Scanner(System.in); DatagramSocket socket = new DatagramSocket();//创建socket while (true){ str = in.nextLine(); if (&quot;quit&quot;.equals(str)){ break; } DatagramPacket packet = new DatagramPacket(str.getBytes(),str.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;),5555);//创建packet,可以使用while循环一直发 socket.send(packet);//发送 } socket.close();//关闭 } } public class Receive {//接收端 public static void main(String[] args) throws Exception{ DatagramSocket socket = new DatagramSocket(5555);//创建SOCKET while (true){ DatagramPacket packet = new DatagramPacket(new byte[1024],1024);//创建packet socket.receive(packet); byte[] arr = packet.getData(); int len = packet.getLength(); String ip = packet.getAddress().getHostAddress();//获取ip地址 int port = packet.getPort(); System.out.println(ip+&quot;:&quot;+port+&quot;:&quot;+new String(arr,0,len)); } } } 2.多线程实现UDP发送接收public class MoreThread {//多线程实现发送与接收 public static void main(String[] args) { new MyReceive().start(); new Send().start(); } } class MyReceive extends Thread{ @Override public void run() { try{ DatagramSocket socket = new DatagramSocket(5555);//创建SOCKET DatagramPacket packet = new DatagramPacket(new byte[1024],1024);//创建packet while (true){ socket.receive(packet); byte[] arr = packet.getData(); int len = packet.getLength(); String ip = packet.getAddress().getHostAddress();//获取ip地址 int port = packet.getPort(); System.out.println(ip+&quot;:&quot;+port+&quot;:&quot;+new String(arr,0,len)); } }catch (IOException e){ e.printStackTrace(); } } } class Send extends Thread{ @Override public void run() { try { String str ; Scanner in = new Scanner(System.in); DatagramSocket socket = new DatagramSocket();//创建socket while (true){ str = in.nextLine(); if (&quot;quit&quot;.equals(str)){ break; } DatagramPacket packet = new DatagramPacket(str.getBytes(),str.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;),5555);//创建packet,可以使用while循环一直发 socket.send(packet);//发送 } socket.close();//关闭 }catch (IOException e){ e.printStackTrace(); } } } 二.TCP协议简单实现TCP协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。第一次握手，客户端向服务器端发出连接请求，等待服务器确认第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求第三次握手，客户端再次向服务器端发送确认信息，确认连接。 public class Dem0_TCP {//客户端 public static void main(String[] args) throws IOException{ Scanner in = new Scanner(System.in);//将键盘录入文字上传服务器 Socket socket = new Socket(&quot;127.0.0.1&quot;,12345);//最多65535 BufferedReader br= new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); ps.println(in.nextLine());//写; System.out.println(br.readLine()); socket.close(); } } public class Homework {//服务器，客户端是Demo——TCP public static void main(String[] args) throws IOException{ ServerSocket serverSocket = new ServerSocket(12345); System.out.println(&quot;服务器启动绑定12345接口&quot;); while (true){ final Socket socket1 = serverSocket.accept(); new Thread(){ @Override public void run() { try{ BufferedReader br= new BufferedReader(new InputStreamReader(socket1.getInputStream())); PrintStream ps = new PrintStream(socket1.getOutputStream()); String line = br.readLine(); line = new StringBuilder(line).reverse().toString();//反转 System.out.println(line); ps.println(line); socket1.close(); }catch (IOException e){ e.printStackTrace(); } } }.start(); } } } 三.TCP/UDP 简单应用1.使用TCP协议将客户端文件上传服务器public class Test {//客户端 public static void main(String[] args) throws IOException { File file = getFile(); Socket socket = new Socket(&quot;127.0.0.1&quot;,12345); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); ps.println(file.getName()); String flag = br.readLine(); if (&quot;文件存在，不用上传&quot;.equals(flag)){ System.out.println(flag); socket.close(); return; }else { System.out.println(flag); } FileInputStream fis = new FileInputStream(file); byte[] arr = new byte[8192]; int len; while ((len=fis.read(arr))!=-1){ ps.write(arr,0,len);//不可以用println会把字节转化为字符 } fis.close(); socket.close(); } private static File getFile() { Scanner in = new Scanner(System.in); System.out.println(&quot;请输入文件路径&quot;); while (true){ File file = new File(in.nextLine()); if (!file.exists()){ System.out.println(&quot;输入的文件路径不存在，重新录入&quot;); }else if (file.isDirectory()){ System.out.println(&quot;文件夹路径，请输入文件路径&quot;); }else{ return file; } } } } public class TestServer {//服务器 public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(12345); System.out.println(&quot;服务器启动绑定12345端口号&quot;); while (true){ final Socket socket = serverSocket.accept(); new Thread(){ @Override public void run() { try { InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); PrintStream ps = new PrintStream(socket.getOutputStream()); String line = br.readLine(); File dir = new File(&quot;update&quot;); dir.mkdir(); File file = new File(dir,line);//父级目录dir if (file.exists()){ ps.println(&quot;文件存在，不用上传&quot;); socket.close(); return; }else { ps.println(&quot;不存在，可以上传&quot;); } FileOutputStream fos = new FileOutputStream(file);//file文件创建好了 byte[] arr = new byte[8192]; int len; while ((len=is.read(arr))!=-1) { fos.write(arr,0,len);//不可以用println会把字节转化为字符 } fos.close(); socket.close(); }catch (IOException e){ e.printStackTrace(); } } }.start(); } } } 2.使用UDP编写简单的聊天工具public class DemoTest extends Frame { TextField tf; Button send; Button clear; Button shake; Button log; TextArea viewText; TextArea sendText; DatagramSocket socket; BufferedWriter bw; public static void main(String[] args) { new DemoTest(); } public DemoTest(){ init(); southPanel(); centerPanel(); event(); } public void event(){ this.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { socket.close(); try { bw.close(); } catch (IOException e1) { e1.printStackTrace(); } System.exit(0); } }); send.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { try { send(); } catch (IOException e1) { e1.printStackTrace(); } } }); log.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { try { logFile(); } catch (IOException e1) { e1.printStackTrace(); } } }); clear.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { viewText.setText(&quot;&quot;); } }); shake.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { shake(); } }); sendText.addKeyListener(new KeyAdapter() { @Override public void keyReleased(KeyEvent e) { if (e.getKeyCode() == KeyEvent.VK_ENTER){//键盘监听 try { send(); } catch (IOException e1) { e1.printStackTrace(); } } } }); } public void shake(){ int x = this.getLocation().x; int y = this.getLocation().y; for (int i=0;i&lt;20;i++){ this.setLocation(x+20,y+20); try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } this.setLocation(x+20,y-20); try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } this.setLocation(x-20,y+20); try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } this.setLocation(x-20,y-20); } } public void logFile() throws IOException{ try { bw.flush();//刷新缓冲区 } catch (IOException e) { e.printStackTrace(); } FileInputStream fis = new FileInputStream(&quot;config.txt&quot;); ByteArrayOutputStream baos = new ByteArrayOutputStream();//内存中创建缓冲区 int len; byte[] arr = new byte[8192]; while ((len = fis.read(arr))!=-1){ baos.write(arr,0,len); } String str = baos.toString(); viewText.setText(str); fis.close(); } public void send() throws IOException { String message = sendText.getText(); String ip = tf.getText();//获取ip地址 DatagramPacket packet = new DatagramPacket(message.getBytes(),message.getBytes().length, InetAddress.getByName(ip),9999); socket.send(packet); String time = getCurrentTime(); String str = time+&quot; 我对：&quot;+ip+&quot;说\r\n&quot;+message+&quot;\r\n\r\n&quot;; viewText.append(str); sendText.setText(&quot;&quot;); bw.write(str); bw.flush(); } private String getCurrentTime() { Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日HH:mm:ss&quot;); return sdf.format(d);//时间格式化 } public void southPanel(){ Panel south = new Panel(); tf = new TextField(15); tf.setText(&quot;127.0.0.1&quot;); send = new Button(&quot;send&quot;);//创建发送按钮 log = new Button(&quot;log&quot;); clear = new Button(&quot;clear&quot;); shake = new Button(&quot;shake&quot;); south.add(tf); south.add(send); south.add(log); south.add(clear); south.add(shake); this.add(south,BorderLayout.SOUTH); } public void centerPanel(){ Panel center = new Panel(); viewText = new TextArea(); sendText = new TextArea(5,1); center.setLayout(new BorderLayout()); center.add(sendText,BorderLayout.SOUTH); center.add(viewText,BorderLayout.CENTER); this.add(center,BorderLayout.CENTER); viewText.setEditable(false); viewText.setBackground(Color.WHITE); sendText.setFont(new Font(&quot;xxx&quot;,Font.PLAIN,15)); viewText.setFont(new Font(&quot;xxx&quot;,Font.PLAIN,15)); } public void init(){ this.setLocation(500,50); this.setSize(400,600); this.setVisible(true); new Receive().start(); try { socket = new DatagramSocket(); bw = new BufferedWriter(new FileWriter(&quot;config.txt&quot;,true)); } catch (Exception e) { e.printStackTrace(); } } private class Receive extends Thread{ @Override public void run() { try{ DatagramSocket socket = new DatagramSocket(9999); DatagramPacket packet = new DatagramPacket(new byte[8192],8192); while (true){ socket.receive(packet); byte[] arr = packet.getData(); int len = packet.getLength(); String message = new String(arr,0,len); String time = getCurrentTime(); String ip = packet.getAddress().getHostAddress(); String str = time+&quot; &quot;+ip+&quot;对我说：\r\n&quot;+message+&quot;\r\n&quot;; viewText.append(str); bw.write(str); bw.flush(); } }catch (IOException e){ e.printStackTrace(); } } } }]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecondDay]]></title>
    <url>%2FDreamRiverForever.github.io%2F2018%2F12%2F31%2FSecondDay%2F</url>
    <content type="text"><![CDATA[I/O流 一.字节流 &amp;&amp; 字符流1.FileInputStream 字节输入流public class Demo1 { public static void main(String[] args) throws IOException{ FileInputStream fis = new FileInputStream(&quot;xxx.txt&quot;); int value; while ((value=fis.read())!=-1) { System.out.println( value); } fis.close(); } } 最低级的字节输入流，每次读入一个字节效率低。接下来介绍带有缓冲区的字节输入流。 2.FileOutputStream 字符输出流public class Demo02 { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;yyy.txt&quot;);//如果想续写在第二个参数传true int count=120; while (count&gt;99){ fos.write(count);//写出的是int数据，文件上自动去除前24位0，形成8字节数据 count--; } fos.close(); } } 每次写入一个字符，效率同样低 3.用字节数组来read() &amp; write()public class Demo3 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;yyy.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;copy.txt&quot;); int lenght=fis.available(); byte[] bytes = new byte[lenght];//在读文件过程中不能写文件，也有可能导致大文件需要的数组太大，虚拟机不能分配大数组内存 fis.read(bytes);//文件上字节读入字节数组 fos.write(bytes);//字节数组中字节读入copy fis.close(); fos.close(); } } 通过fis.available()获取读入字节大小，创建一个同等大小的byte数组一次性读入，在将byte数组一次写出。相比于读一个字节与写一个字节效率提高许多，但是当文件过大时，读取时间很长，在此期间不能够写文件必须等字节全部读入byte数组中才能写。而且JVM有时候不能分配太大的byte数组。所以不建议使用此方法。建议使用下面小byte数组方法。 public class Demo4 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;xxx.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;zzz.txt&quot;); byte[] arr = new byte[3];//建议1024*n，就是1024的整数倍 int len; while ((len=fis.read(arr))!=-1){//如果不写arr返回的是AS2码值，len长度变了，write写入len个空字符。 fos.write(arr,0,len);//取消len后面的字符，防止重复 } fis.close(); fos.close(); } } 通过len获取读入数据长度非常有必要，当写byte中数据时，有可能此次读入的字节没有完全覆盖上次读入字节，导致写入多余的字节。通过len可以指定写入字节大区间，从而去除多余字节。 4.BufferedInputStream &amp;&amp; BufferedOutputStream 带有缓冲区输入输出流public class Demo5 { public static void main(String[] args)throws IOException { FileInputStream fis = new FileInputStream(&quot;zzz.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;zz.txt&quot;); BufferedInputStream bis = new BufferedInputStream(fis);//带缓冲区的输入流 BufferedOutputStream bos = new BufferedOutputStream(fos); int b; while ((b=bis.read())!=-1){ bos.write(b); } bis.close();//flush也具备及时刷新功能，flush刷完还可以写，close关闭流。 bos.close();//具备刷新功能，关闭流之前刷新一次缓冲区，将缓冲区中的文件刷新到文件中。有可能缓冲区没有装满，没能传到文件中close可以强制把缓冲区中字节输出 } } 通过装饰设计模式，在BufferedInputStream或BufferedOutputStream中传入对应的子类对象在对其进行包装实现更加强大的功能。通过在内存中增加缓冲区实现byte同样的功能，BufferedInputStream继承于FilterInputStream，提供缓冲输入流功能。缓冲输入流相对于普通输入流的优势是，它提供了一个缓冲数组，每次调用read方法的时候，它首先尝试从缓冲区里读取数据，若读取失败（缓冲区无可读数据），则选择从物理数据源（譬如文件）读取新数据（这里会尝试尽可能读取多的字节）放入到缓冲区中，最后再将缓冲区中的内容部分或全部返回给用户.由于从缓冲区里读取数据远比直接从物理数据源（譬如文件）读取速度快。在每次读完结束都要刷新缓冲区即close方法，防止缓冲区没有装满而没有自动刷新丢失数据。 5.用字节流读 &amp; 写中文public class Demo6 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;zw.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;zw2.txt&quot;); byte[] arr = new byte[3]; int len; while ((len = fis.read(arr)) != -1) { System.out.println(new String(arr,0,len)); } fis.close(); fos.write(&quot;我六级挂了&quot;.getBytes());//转化为字节数组 fos.close(); } } 由于utf-8中一个中文三个字节，所以byte大小设置3，如果设置不为3的倍数，比如读入4字节，通过String解析三个字节多一个字节就乱码，同时后面的中文由于前面丢失一字节导致全部乱码。(不推荐使用)。通过字节流输出中文需要把中文转化为字节数组写出比较麻烦。 6.FileReader &amp; FileWriter 字符流输入输出流public class Demo10 { public static void main(String[] args)throws IOException { FileReader fid = new FileReader(&quot;zw.txt&quot;);//字符流 int x; while ((x=fid.read())!=-1){ System.out.print((char)x); } fid.close(); } } public class Demo11 { public static void main(String[] args)throws IOException { FileWriter fiw = new FileWriter(&quot;zw3.txx&quot;); fiw.write(&quot;你好我是何佳楠&quot;); fiw.close(); } } 原理与字节流等同，但是FileReader提供read.line()方法，可以一次读入一行数据以\r\n结束 public class Demo12 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;zzz.txt&quot;)); String line; while ((line=br.readLine())!=null){//读一行 System.out.println(line); } br.close(); } } FileReader提供换行方法newLine()，可以换行，但是你也可以使用写入\r\n来换行，与\r\n相比newLine()全平台可用，后者只在windows下有用，推荐newLine() 7.LineNumberReader带行号的字符读入流public class Demo14 { public static void main(String[] args) throws IOException{ LineNumberReader lnr = new LineNumberReader(new FileReader(&quot;zzz.txt&quot;)); String line; //lnr.setLineNumber(100);行号初始值得设定 while ((line=lnr.readLine())!=null){ System.out.println(lnr.getLineNumber()+&quot; &quot;+line);//加行号 } } } 可以通过getLineNumber()方法获取行号。 8. SequenceInputStream合并流public class Demo18 { public static void main(String[] args) throws IOException { SequenceInputStream si = new SequenceInputStream(new FileInputStream(&quot;xxx.txt&quot;),new FileInputStream(&quot;xxxxx.txt&quot;)); FileOutputStream fos = new FileOutputStream(&quot;xx.txt&quot;); int b; while ((b=si.read())!=-1){ fos.write(b); } si.close(); fos.close(); } } 将两个流合并成一个流，也可以将多个流整合在一起，在SequenceInputStream中传入枚举实例如下 public class Demo19 { public static void main(String[] args) throws IOException {//可以用于歌曲串烧，多首个合在一起 Vector&lt;InputStream&gt; v = new Vector&lt;&gt;(); v.add(new FileInputStream(&quot;xx.txt&quot;)); v.add(new FileInputStream(&quot;xxx.txt&quot;)); v.add(new FileInputStream(&quot;xxxx.txt&quot;)); Enumeration&lt;InputStream&gt; en = v.elements(); SequenceInputStream sis = new SequenceInputStream(en); FileOutputStream fos = new FileOutputStream(&quot;x.txt&quot;); int b; while ((b=sis.read())!=-1){ fos.write(b); } sis.close(); fos.close(); } } 可以用于合并歌曲实现歌曲串烧 9.ByteArrayOutputStream内存输出流public class Demo20 { /* * 内存输出流 */ public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;zw.txt&quot;); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int b; while ((b=fis.read())!=-1){ bos.write(b);//写入内存中 } /* *byte[] arr = bos.toByteArray();//转为字节数组 *System.out.println(new String(arr));//转为字符串 */ System.out.println(bos.toString());//将缓冲区的内容转化为字符串 fis.close(); } } public class Demo21 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;zw.txt&quot;); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] arr = new byte[5];//读字符流容易乱码 int len; while ((len=fis.read(arr))!=-1){ bos.write(arr,0,len);//先读入内存 } System.out.println(bos);//通过转成字符串 } } 将缓冲区的内容转化为字符串，不用再通过String转化 10. RandomAccessFileRandomAccessFile是Java输入/输出流体系中功能最丰富的文件内容访问类，既可以读取文件内容，也可以向文件输出数据。与普通的输入/输出流不同的是，RandomAccessFile支持跳到文件任意位置读写数据，RandomAccessFile对象包含一个记录指针，用以标识当前读写处的位置，当程序创建一个新的RandomAccessFile对象时，该对象的文件记录指针对于文件头（也就是0处），当读写n个字节后，文件记录指针将会向后移动n个字节。除此之外，RandomAccessFile可以自由移动该记录指针。RandomAccessFile包含两个方法来操作文件记录指针： long getFilePointer()：返回文件记录指针的当前位置 void seek(long pos)：将文件记录指针定位到pos位置 RandomAccessFile类在创建对象时，除了指定文件本身，还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，该参数有如下四个值： r：以只读方式打开指定文件。如果试图对该RandomAccessFile指定的文件执行写入方法则会抛出IOExceptionrw：以读取、写入方式打开指定文件。如果该文件不存在，则尝试创建文件rws：以读取、写入方式打开指定文件。相对于rw模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备，默认情形下(rw模式下),是使用buffer的,只有cache满的或者使用RandomAccessFile.close()关闭流的时候儿才真正的写到文件rwd：与rws类似，只是仅对文件的内容同步更新到磁盘，而不修改文件的元数据 public class RandomAccessRead { public static void main(String[] args) { if (args == null || args.length == 0) { throw new RuntimeException(&quot;请输入路径&quot;); } RandomAccessFile raf = null; try { raf = new RandomAccessFile(args[0], &quot;r&quot;); System.out.println(&quot;RandomAccessFile的文件指针初始位置:&quot; + raf.getFilePointer()); raf.seek(100); byte[] bbuf = new byte[1024]; int hasRead = 0; while ((hasRead = raf.read(bbuf)) &gt; 0) { System.out.print(new String(bbuf, 0, hasRead)); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if (raf != null) { raf.close(); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } 11.ObjectOutputStream &amp; ObjectInputStream对象输入输出流主要的作用是用于写入对象信息与读取对象信息。 对象信息一旦写到文件上那么对象的信息就可以做到持久化了。对象的输出流将指定的对象写入到文件的过程，就是将对象序列化的过程，对象的输入流将指定序列化好的文件读出来的过程，就是对象反序列化的过程。既然对象的输出流将对象写入到文件中称之为对象的序列化，那么可想而知对象所对应的class必须要实现Serializable接口。（查看源码可得知：Serializable接口没有任何的方法，只是作为一个标识接口存在）。 public class Demo23 { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;aa.txt&quot;)); Person p1 = new Person(&quot;qqq&quot;,20); Person p2 = new Person(&quot;www&quot;,20); oos.writeObject(p1); oos.writeObject(p2);//也可以把多个对象加入list在存入文件中writeObject(list) oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;aa.txt&quot;)); Person p3 = (Person) ois.readObject(); Person p4 = (Person) ois.readObject();//通过foreach读list System.out.println(p3); System.out.println(p4); ois.close(); } } class Person implements Serializable{ private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return &quot;name=&quot;+name+&quot; &quot;+&quot;age=&quot;+age; } } 12.Properties用于读取配置文件public class Demo24 { public static void main(String[] args) throws IOException { Properties prop = new Properties();//用于读取配置文件 prop.load(new FileInputStream(&quot;com.properties&quot;));//加载配置文件 prop.setProperty(&quot;tel&quot;,&quot;18952122212&quot;);//修改文件内容 prop.store(new FileOutputStream(&quot;com.properties&quot;),&quot;jkv&quot;);//重写刷新文件，第二个参数用来描述文件列表的 System.out.println(prop); } } 二. I/O流的简单应用1.简单的文件加密public class Demo8 { public static void main(String[] args)throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;xxxx.txt&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;xxxxx.txt&quot;)); int b; while ((b=bis.read())!=-1){ bos.write(b ^ 123);//异或一个数，这个数就是秘钥，解密再次异或就行 } bis.close(); bos.close(); } } 通过对每次读入字节异或一个特定数，原理是一个数异或一数两次等于本身。那个特定的数就是秘钥。想要解密就在读一次并且异或一次。 2.拷贝一个文件public class Demo9 { public static void main(String[] args)throws IOException{ File file = getfile(); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file.getName())); int b; while ((b=bis.read())!=-1){ bos.write(b); } bis.close(); bos.close(); } public static File getfile(){ Scanner in = new Scanner(System.in); while (true){ String line = in.nextLine(); File file = new File(line); if (!file.exists()){ System.out.println(&quot;文件路径不存在，重新录入&quot;); } else if (file.isDirectory()){ System.out.println(&quot;文件夹路径，重新录入&quot;); } else { return file; } } } } 3.统计文件中各个字符的个数public class Demo15 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;zzz.txt&quot;)); Map&lt;Character, Integer&gt; tm = new TreeMap&lt;&gt;(); int ch; while ((ch=br.read())!=-1){ char c = (char)ch; tm.put(c,!tm.containsKey(c)? 1:tm.get(c)+1); } br.close(); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;times.txt&quot;)); for (Character key:tm.keySet()) { switch (key){ case &apos;\t&apos;: bw.write(&quot;\\t&quot; +&quot;=&quot;+tm.get(key)); break; case &apos;\n&apos;: bw.write(&quot;\\n&quot; +&quot;=&quot;+tm.get(key)); break; case &apos;\r&apos;: bw.write(&quot;\\r&quot; +&quot;=&quot;+tm.get(key)); break; default: bw.write(key +&quot;=&quot;+tm.get(key)); } bw.newLine(); } bw.close(); } } switch部分因为在输出\r,\n,\t,特殊符号系统默认换行制表等所以在switch中进行转义。 4.使用新软件提示使用次数public class Demo16 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;xxxx.txt&quot;)); String line; line = br.readLine(); br.close(); int time = Integer.parseInt(line); if (time&gt;0){ System.out.println(&quot;您还有&quot;+time--+&quot;次机会&quot;); }else{ System.out.println(&quot;使用次数使用完，请购买正版软件&quot;); } FileWriter fw = new FileWriter(&quot;xxxx.txt&quot;); fw.write(time+&quot;&quot;); fw.close(); } } 只能通过read.Line()读取，通过读入一个字节或字符不能还原一个int型数字比如10，每次读一个字节就是1,0不能真实显示，故使用读一行在转int型。 5.递归实现获取文件夹中指定后缀的文件public class Demo17{ public static void main(String[] args) { File dir= getDir(); print(dir); } public static File getDir(){ Scanner in = new Scanner(System.in); System.out.println(&quot;请输入文件夹路径&quot;); while (true){ String line = in.nextLine(); File file = new File(line); if (!file.exists()){ System.out.println(&quot;文件路径不存在，重新录入&quot;); } else if (file.isFile()){ System.out.println(&quot;文件路径，重新录入文件夹路径&quot;); } else { return file; } } } public static void print(File file){ File[] arr = file.listFiles();//file中文件夹全部放入arr for (File subfile:arr){ if (subfile.isFile()&amp;&amp;subfile.getName().endsWith(&quot;.java&quot;)){ System.out.println(subfile); }else if (subfile.isDirectory()){ print(subfile); } } } } 6.递归打印文件夹树形目录public class Didui4 { public static void main(String[] args) { File dir = Digui.getDir();//获取文件夹路径 printLev(dir,0); } private static void printLev(File dir,int lev) { File[] subs = dir.listFiles(); for (File sub:subs) { for (int i=0;i&lt;lev;i++){ System.out.print(&quot;\t&quot;); } System.out.println(sub.getName()); if (sub.isDirectory()){ printLev(sub,lev+1); } } } } 7.统计文件夹大小public class Digui { public static void main(String[] args) { File dir = getDir(); System.out.println(getFilelength(dir)); } public static File getDir(){ Scanner in = new Scanner(System.in); System.out.println(&quot;请输入文件夹路径&quot;); while (true){ String line = in.nextLine(); File file = new File(line); if (!file.exists()){ System.out.println(&quot;文件路径不存在，重新录入&quot;); } else if (file.isFile()){ System.out.println(&quot;文件路径，重新录入文件夹路径&quot;); } else { return file; } } } public static long getFilelength(File dir){ long len = 0; File[] subfiles = dir.listFiles(); for (File subfile:subfiles) { if (subfile.isFile()){ len+=subfile.length(); }else { len+=getFilelength(subfile); } } return len; } } 8.删除文件夹public class Digui2 { /* *键盘接受一个文件夹，并且删除 */ public static void main(String[] args) { File dir = Digui.getDir(); deleteFile(dir); } public static void deleteFile(File dir){ File[] subs = dir.listFiles(); for (File sub:subs) { if (sub.isFile()){ sub.delete(); } else { deleteFile(sub); } } dir.delete(); } } 9.反转文件public class Homework2 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;zzz.txt&quot;)); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); String line; while ((line=br.readLine())!=null){ list.add(line); } br.close(); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;zzzz.txt&quot;)); for (int i=list.size()-1;i&gt;=0;i--){ bw.write(list.get(i)); bw.newLine(); } bw.close(); } }]]></content>
      <categories>
        <category>I/O流</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstDay]]></title>
    <url>%2FDreamRiverForever.github.io%2F2018%2F12%2F30%2FFirstDay%2F</url>
    <content type="text"><![CDATA[多线程 一.实现多线程的两种方式1：继承Thread类重写run方法public class Demo1 { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start();//开启线程 for (int i=0;i&lt;100;i++){ System.out.println(&quot;bb&quot;); } } } class MyThread extends Thread{ @Override public void run() { for (int i=0;i&lt;100;i++) System.out.println(&quot;aaaaa&quot;); } } 2:实现Runnable接口在Thread构造函数中传入Runnable子类对象public class Demo2 { public static void main(String[] args) { MyRunnable mr = new MyRunnable(); Thread t =new Thread(mr);//传入Runnable子类对象 t.start();//开启线程 for (int i=0;i&lt;100;i++) System.out.println(&quot;bb&quot;); } } class MyRunnable implements Runnable{//实现Runnable接口 @Override public void run() {//重写run方法 for (int i=0;i&lt;100;i++) System.out.println(Thread.currentThread().getName()+i); } } 3:使用线程池创建多线程public class Demo21_Executors {//线程池 public static void main(String[] args) { ExecutorService pool = Executors.newFixedThreadPool(2); pool.submit(new Thread(new MyRunnable())); pool.submit(new Thread(new MyRunnable())); pool.shutdown();//关闭线程池 } } 线程池中线程不会死亡，可以减少线程的创建但是浪费资源 二.使用匿名内部类实现线程public class Demo3 { public static void main(String[] args) {//匿名内部类 new Thread(){//继承Threadlei @Override public void run() {//重写run方法 for (int i=0;i&lt;100;i++) System.out.println(&quot;aaaaa&quot;); } }.start(); new Thread(new Runnable() {//将runnable子类对象放入Thread构造函数 @Override public void run() { for (int i=0;i&lt;100;i++) System.out.println(&quot;bbb&quot;); } }).start(); } } 三.线程的一些使用方法1.setname用于设置线程名称public class Demo4 { public static void main(String[] args) { new Thread(){//可以传入字符串命名 @Override public void run() { this.setName(&quot;dengyuwen&quot;);//也可以setname方法设置名字 System.out.println(this.getName()+&quot; aaa&quot;);//获取线程的name } }.start(); new Thread(){ @Override public void run() { this.setName(&quot;hejianan&quot;); System.out.println(this.getName()+&quot; bbb&quot;); } }.start(); } } 2.getname用于获取线程名称public class Demo5 { public static void main(String[] args) { new Thread(){ @Override public void run() { System.out.println(getName()+&quot; aaa&quot;);//获取线程名称 } }.start(); new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot; bbb&quot;);//Thread.currentThread()获取当前执行线程，因为Runnable没有getname方法 } }).start(); } } 3.sleep用于休眠线程public class Demo6Sleep { public static void main(String[] args) { for (int i=20;i&gt;=0;i--){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;倒计时第&quot;+i+&quot;秒&quot;); } } } 4.Daemon守护线程public class Demo7Daemon {//守护线程 public static void main(String[] args) { Thread t1 = new Thread(){ @Override public void run() { for (int i=0;i&lt;2;i++) System.out.println(getName()+&quot; aaaaa&quot;); } }; Thread t2 = new Thread(){ @Override public void run() { for (int i=0;i&lt;12;i++) System.out.println(getName()+&quot; bbbbb&quot;); } }; t2.setDaemon(true);//设置守护线程，当非守护线程死亡守护线程也死亡 t1.start(); t2.start(); } } 设置守护线程，当非守护线程死亡守护线程也死亡 5.join加入线程public class Demo8Join {//加入线程 public static void main(String[] args) { final Thread t1 = new Thread(){ @Override public void run() { for (int i=0;i&lt;12;i++) System.out.println(getName()+&quot; aaaaa&quot;); } }; final Thread t2 = new Thread(){ @Override public void run() { for (int i=0;i&lt;12;i++){ if (i==2) { try { t1.join();//插队，t2执行两次，t1加入执行到结束t2才能执行。在join中可以传入插队时间 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(getName()+&quot; bbbbb&quot;); } } }; t1.start(); t2.start(); } } 6.SetPriority线程优先级public class Demo10SetPriority {//设置进程优先级 public static void main(String[] args) { Thread t1 = new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ System.out.println(getName()+&quot; aaa&quot;); } } }; Thread t2 = new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ System.out.println(getName()+&quot; bbb&quot;); } } }; t1.setPriority(10);//优先级10最大，1最小 t2.setPriority(1); t1.start(); t2.start(); } } 设置优先级不意味着按照优先级执行，而是给cup提供资源分配提示，最后还是由cup决定执行顺序 7.synchronized同步代码块(重要)public class Demo11syn { //同步代码块 public static void main(String[] args) { final Printer p = new Printer(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print2(); } } }.start(); } } class Printer{ Demo d = new Demo(); public void print1(){ synchronized (d){//同步锁传入同一个对象必须执行完括号里面的代码 System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); } } public void print2(){ synchronized (d){//必须同一对象 System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); } } } class Demo{ } 线程在cup分给的时间片使用完后，有可能代码执行一半而转去执行其他线程，这样容易引起线程安全问题，同步代码块强制执行完整代码才释放锁对象。例如在火车买票剩余2张，2&gt;0于是进入买票，在买票过程中cup分配的时间用完转去执行其他线程，有可能在此期间票卖完。但是在又获取时间片后线程继续执行，但是票卖完，于是ticket–，变成-1等等一些负数，引起线程不安全。使用synchronized关键字，在进入代码块后必须执行完才推出即释放锁对象。除非有wait()方法提前释放了锁对象。 8.锁对象可以使任意的public class Demo12syn2 { public static void main(String[] args) { final Printer2 p = new Printer2(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { for (int i=0;i&lt;1000;i++){ p.print2(); } } }.start(); } } class Printer2{ Demo d = new Demo(); //非静态同步方法的锁对象是this //静态同步方法锁对象时字节文件.class public synchronized void print1(){ System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); } public void print2(){ synchronized (this){ System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); } } } 9.火车买票问题public class Demo13 { public static void main(String[] args) { MyTicket mt = new MyTicket();//创建一次对象ticket不在需要共用 new Thread(mt).start();//锁对象可以用this new Thread(mt).start();//多次启动一个线程是非法的 new Thread(mt).start(); new Thread(mt).start(); } } class MyTicket implements Runnable{ private int ticket=100; @Override public void run() { while (true){ synchronized (Ticket.class){//同步代码块。参数必须是同一把锁，引用对象必须是静态的 if (ticket==0) break; try { Thread.sleep(10);//线程1234等于1时，每次减一变成负数跳过ticket==0判断买负数票，所以必须同步ticket--。 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot; 这是第 &quot;+ticket--+&quot; 号票&quot;); } } } } 10.哲学家就餐问题public class Demo14deadlock { private static String s1=&quot;筷子左&quot;; private static String s2=&quot;筷子右&quot;; public static void main(String[] args) {//死锁避免同步代码块嵌套 new Thread(){ @Override public void run() { while (true){ synchronized (s1){ System.out.println(getName()+&quot; 获取 &quot;+s1+&quot; 等待 &quot;+s2);//获取不到s2 synchronized (s2){ System.out.println(getName()+&quot; 拿到 &quot;+s2+&quot;开吃&quot;); } } } } }.start(); new Thread(){ @Override public void run() { while (true){ synchronized (s2){ System.out.println(getName()+&quot; 获取 &quot;+s2+&quot; 等待 &quot;+s1); synchronized (s1){//获取不到s1 System.out.println(getName()+&quot; 拿到 &quot;+s1+&quot;开吃&quot;); } } } } }.start(); } } 11.Singleton单例设计模式(重要)public class Demo15Singleton {//单例设计模式 public static void main(String[] args) { SingLeton s1 = SingLeton.getS(); SingLeton s2 = SingLeton.getS(); System.out.println(s1==s2); } } //饿汉式 比较好 class SingLeton{ private SingLeton(){//私有构造方法，其他类不能访问该方法 } //也可以public，但是必须加final关键字，不可改变，只能创建一个对象 private static SingLeton s = new SingLeton();//设置为静态可以使用类名点s public static SingLeton getS() {//只能拿不能改 return s; } } //懒汉式 线程不安全 class SingLeton2{ private SingLeton2(){//私有构造方法，其他类不能访问该方法 } private static SingLeton2 s; public static SingLeton2 getS() {//只能拿不能改 if (s == null){ //线程1进入等待，线程2进入，创建了两个对象不是单例设计模式 s = new SingLeton2(); } return s; } } /* *饿汉式空间换时间，先创建对象浪费内存，调用快 * 懒汉式是时间换空间，先声明不创建，在判断要不要创建，浪费时间 * 在多线程访问时饿汉式不会创建多个对象，懒汉式有可能创建多个对象 */ 12.Timer定时器public class Demo17Timer { public static void main(String[] args) {//定时器,指定时间安排指定任务 Timer t = new Timer(); t.schedule(new MyTimerTask(),new Date());//参数安排任务，执行的时间，过多长时间在重复执行 } } class MyTimerTask extends TimerTask{ @Override public void run() { System.out.println(&quot;起来了背书了&quot;); } } 在指定时间执行特定的任务 13.wait &amp; notify等待唤醒机制public class Demo18_notify {//等待唤醒机制 public static void main(String[] args) { final Printer3 p= new Printer3(); new Thread(){ @Override public void run() { while(true) { p.print1(); } } }.start(); new Thread(){ @Override public void run() { while(true) { p.print2(); } } }.start(); } } class Printer3{ private int flag=1; public void print1(){ synchronized (this){ if (flag!=1){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); flag = 2; this.notify(); } } public void print2(){ synchronized (this){ if (flag!=2){ try { this.wait();//进入等待线程队列 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); flag = 1; this.notify();//随机唤醒一个线程 } } } 随机唤醒一个线程，由于线程在哪里等待就在那里唤醒有可能越过if判断。所以提前释放锁对象容易出现线程安全。 14.notifyall唤醒全部线程public class Demo19_notifyall { public static void main(String[] args) { Printer4 p = new Printer4(); new Thread(){ @Override public void run() { while (true){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { while (true){ p.print2(); } } }.start();new Thread(){ @Override public void run() { while (true){ p.print3(); } } }.start(); } } /* *用什么对象锁，就要用那个对象调用wait方法 * wait、notify方法必须在object中，object是所有类的基类，锁对象可以使任意的。 * */ class Printer4{ private int flag=1; public void print1(){ synchronized (this){ while (flag!=1){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); flag = 2; this.notifyAll(); } } public void print2(){ synchronized (this){ while (flag!=2){ try { this.wait();//进入等待线程队列 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); flag = 3; this.notifyAll();//随机唤醒所有线程 } } public void print3(){ synchronized (this){ while (flag!=3){ try { this.wait();//进入等待线程队列 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;i&quot;); System.out.print(&quot;t&quot;); System.out.print(&quot;h&quot;); System.out.print(&quot;m&quot;); System.out.println(); flag = 1; this.notifyAll();//随机唤醒所有线程 } } } notify容易造成死锁，例如flag = 1 执行完 flag = 2 随机唤醒线程3，由于使用while判断所以不能越过，2！= 3 所以线程3再次等待，至此没有执行的线程，所有线程都在等待，造成死锁。使用notifyll唤醒所有线程可以保证有执行的线程，不至于死锁。 15.ReentrantLock同步锁(重要)public class Demo20_ReentrantLock { public static void main(String[] args) { final Printer5 p = new Printer5(); new Thread(){ @Override public void run() { while (true){ p.print1(); } } }.start(); new Thread(){ @Override public void run() { while (true){ p.print2(); } } }.start(); new Thread(){ @Override public void run() { while (true){ p.print3(); } } }.start(); } } class Printer5{ private ReentrantLock r = new ReentrantLock(); private Condition c = r.newCondition(); private Condition c1 = r.newCondition(); private Condition c2 = r.newCondition(); private int flag=1; public void print1(){ r.lock(); if (flag!=1){ try { c.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.println(); flag = 2; c1.signal(); r.unlock(); } public void print2(){ r.lock(); if (flag!=2){ try { c1.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.println(); flag = 3; c2.signal(); r.unlock(); } public void print3(){ r.lock(); if (flag!=3){ try { c2.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(&quot;i&quot;); System.out.print(&quot;t&quot;); System.out.print(&quot;h&quot;); System.out.print(&quot;m&quot;); System.out.println(); flag = 1; c.signal(); r.unlock(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
